package beegfs

import (
	"bytes"
	"crypto/sha1"
	"fmt"
	"io/ioutil"
	"net/url"
	"os"
	"os/exec"
	"path"
	"strconv"
	"strings"

	"github.com/golang/glog"
	"github.com/spf13/afero"
	"gopkg.in/ini.v1"
	"k8s.io/utils/mount"
)

// We use afero to abstract the file system. During unit tests, we use an in-memory file system (afero.NewMemFs). In an
// actual deployment, we use the host's file system.
var fs = afero.NewOsFs()
var fsutil = afero.Afero{Fs: fs}

// newBeegfsUrl converts a hostname or IP address and path into a URL
func newBeegfsUrl(host string, path string) string {
	structURL := url.URL{
		Scheme: "beegfs",
		Host:   host,
		Path:   path,
	}
	return structURL.String()
}

// parseBeegfsUrl parses a URL and returns a sysMgmtdHost and path
func parseBeegfsUrl(rawUrl string) (sysMgmtdHost string, path string, err error) {
	var structUrl *url.URL
	if structUrl, err = url.Parse(rawUrl); err != nil {
		return "", "", err
	}
	if structUrl.Scheme != "beegfs" {
		return "", "", fmt.Errorf("URL has incorrect scheme")
	}
	// TODO(webere) more checks for bad values
	return structUrl.Host, structUrl.Path, nil
}

// beegfsCtlExec executes arbitrary beegfs-ctl commands like "beegfs-ctl --arg1 --arg2=value". It logs the stdout and
// stderr when running at a high verbosity and returns stdout as a string (as well as any potential errors).
// beegfsCtlExec fails if beegfs-ctl is not on the PATH.
func beegfsCtlExec(cfgFilePath string, args []string) (stdOut string, err error) {
	args = append([]string{fmt.Sprintf("--cfgFile=%s", cfgFilePath)}, args...)
	cmd := exec.Command("beegfs-ctl", args...)
	glog.Infof("Executing command: %s", cmd.Args)

	var stdoutBuffer bytes.Buffer
	var stderrBuffer bytes.Buffer
	cmd.Stdout = &stdoutBuffer
	cmd.Stderr = &stderrBuffer

	err = cmd.Run()
	stdOutString := stdoutBuffer.String()
	stdErrString := stderrBuffer.String()
	if err != nil {
		fmt.Println(err.Error())
		if strings.Contains(stdErrString, "does not exist") {
			err = newCtlNotExistError(stdOutString, stdErrString)
		} else if strings.Contains(stdErrString, "exists already") {
			err = newCtlExistError(stdOutString, stdErrString)
		} else {
			err = fmt.Errorf("beegfs-ctl failed: %w", err)
		}
	}
	glog.V(5).Infof(stdOutString)
	glog.V(5).Infof(stdErrString)

	return stdOutString, err
}

// ctlNotExistError indicates that beegfs-ctl failed to stat or modify an entry that does not exist.
type ctlNotExistError struct {
	stdOutString string
	stdErrString string
}
func newCtlNotExistError(stdOutString, stdErrString string) ctlNotExistError {
	return ctlNotExistError{stdOutString: stdOutString, stdErrString: stdErrString}
}
func (err ctlNotExistError) Error() string{
	return fmt.Sprintf("beegfs-ctl failed with stdOut: %v and stdErr: %v", err.stdOutString, err.stdErrString)
}

// ctlExistError indicates the beegfs-ctl failed to create an entry that already exists.
type ctlExistError struct {
	stdOutString string
	stdErrString string
}
func newCtlExistError(stdOutString, stdErrString string) ctlExistError {
	return ctlExistError{stdOutString: stdOutString, stdErrString: stdErrString}
}
func (err ctlExistError) Error() string{
	return fmt.Sprintf("beegfs-ctl failed with stdOut: %v and stdErr: %v", err.stdOutString, err.stdErrString)
}

// writeClientFiles writes a beegfs-client.conf file and optionally a connInterfacesFile, a connNetFilterFile, and a
// connTcpOnlyFilterFile to the directory given by mountDirPath. The beegfs-client.conf file is generated by reading in
// an existing beegfs-client.conf file at confTemplatePath and overriding its values with those specified in beegfsConfig.
// writeClientFiles assumes an empty directory has already been created at mountDirPath. The final directory structure
// looks like:
//                                            mountDirPath/
//                                                  |
//         +--------------------+-------------------+---------------------+----------------+
//         |                    |                   |                     |                |
// beegfs-client.conf   connInterfacesFile   connNetFilterFile   connTcpOnlyFilterFile   mount/
func writeClientFiles(sysMgmtdHost, mountDirPath, confTemplatePath string, overrides beegfsConfig) (clientConfPath,
	mountPath string, err error) {
	connInterfacesFilePath := path.Join(mountDirPath, "connInterfacesFile")
	connNetFilterFilePath := path.Join(mountDirPath, "connNetFilterFile")
	connTcpOnlyFilterFilePath := path.Join(mountDirPath, "connTcpOnlyFilterFile")
	clientConfPath = path.Join(mountDirPath, "beegfs-client.conf")
	mountPath = path.Join(mountDirPath, "mount")

	// setConfigValueIfKeyExists is a helper function used to get around the fact that the go-ini library will allows
	// setting the value of an arbitrary key, even if the key did not exist in the original .ini file.
	// setConfigValueIfKeyExists returns an error if the supplied key did not exist in the original .ini file.
	setConfigValueIfKeyExists := func(iniFile *ini.File, key, value string) error {
		if iniFile.Section("").HasKey(key) {
			iniFile.Section("").Key(key).SetValue(value)
		} else {
			return fmt.Errorf("%v not in template beegfs-client.conf file", key)
		}
		return nil
	}

	// TODO(webere): consider a more efficient/effective way of deciding on a UDP port
	// TODO(webere): document that connClientPortUDP is NOT a supported option (maybe a range?)
	// randomly select a UDP port to use for this volume mount
	var connClientPortUDP string
	for i := 49152; i < 65535; i++ {
		available, err := isUDPPortAvailable(strconv.Itoa(i))
		if err != nil {
			return "", "", err
		} else if available == true {
			connClientPortUDP = strconv.Itoa(i)
			break
		}
	}

	// TODO (webere): consider loading the template globally only once
	var clientConfBytes []byte
	var clientConfINI *ini.File
	clientConfBytes, err = fsutil.ReadFile(confTemplatePath)
	if err != nil {
		return "", "", fmt.Errorf("error loading beegfs-client.conf file at %s: %v", confTemplatePath, err)
	}
	clientConfINI, err = ini.Load(clientConfBytes)
	if err != nil {
		return "", "", fmt.Errorf("error parsing template beegfs-client.conf file: %v", err)
	}
	if err = setConfigValueIfKeyExists(clientConfINI, "sysMgmtdHost", sysMgmtdHost); err != nil {
		return "", "", err
	}
	if err = setConfigValueIfKeyExists(clientConfINI, "connClientPortUDP", connClientPortUDP); err != nil {
		return "", "", err
	}
	for k, v := range overrides.BeegfsClientConf {
		if err := setConfigValueIfKeyExists(clientConfINI, k, v); err != nil {
			return "", "", err
		}
	}

	if len(overrides.ConnInterfaces) != 0 {
		connInterfacesFileContents := strings.Join(overrides.ConnInterfaces, "\n") + "\n"
		err := setConfigValueIfKeyExists(clientConfINI, "connInterfacesFile", connInterfacesFilePath)
		if err != nil {
			return "", "", err
		}
		err = fsutil.WriteFile(connInterfacesFilePath, []byte(connInterfacesFileContents), 0644)
		if err != nil {
			return "", "", fmt.Errorf("error writing connInterfacesFile: %v", err)
		}
	}

	if len(overrides.ConnNetFilter) != 0 {
		connNetFilterFileContents := strings.Join(overrides.ConnNetFilter, "\n") + "\n"
		err := setConfigValueIfKeyExists(clientConfINI, "connNetFilterFile", connNetFilterFilePath)
		if err != nil {
			return "", "", err
		}
		err = fsutil.WriteFile(connNetFilterFilePath, []byte(connNetFilterFileContents), 0644)
		if err != nil {
			return "", "", fmt.Errorf("error writing connNetFilterFile: %v", err)
		}
	}

	if len(overrides.ConnTcpOnlyFilter) != 0 {
		connTcpOnlyFilterFileContents := strings.Join(overrides.ConnTcpOnlyFilter, "\n") + "\n"
		err := setConfigValueIfKeyExists(clientConfINI, "connTcpOnlyFilterFile", connTcpOnlyFilterFilePath)
		if err != nil {
			return "", "", err
		}
		err = fsutil.WriteFile(connTcpOnlyFilterFilePath, []byte(connTcpOnlyFilterFileContents), 0644)
		if err != nil {
			return "", "", fmt.Errorf("error writing connNetFilterFile: %v", err)
		}
	}

	clientConfFileHandle, err := fs.Create(clientConfPath)
	if err != nil {
		return "", "", fmt.Errorf("error creating beegfs-client.conf file: %v", err)
	}
	_, err = clientConfINI.WriteTo(clientConfFileHandle)
	if err != nil {
		return "", "", fmt.Errorf("error writing beegfs-client.conf file: %v", err)
	}

	return clientConfPath, mountPath, nil
}

// squashConfigForSysMgmtdHost takes a pluginConfig, which MAY have FileSystemSpecificConfigs and a sysMgmtdHost. If
// the pluginConfig contains overrides for the provided sysMgmtdHost, squashConfigForSysMgmtdHost combines them with
// the DefaultConfig (giving preference to the appropriate fileSystemSpecificConfig). Otherwise, it returns the
// DefaultConfig.
func squashConfigForSysMgmtdHost(sysMgmtdHost string, config pluginConfig) (returnConfig beegfsConfig) {
	returnConfig = *newBeegfsConfig()
	returnConfig.overwriteFrom(config.DefaultConfig)
	for _, fileSystemSpecificConfig := range config.FileSystemSpecificConfigs {
		if sysMgmtdHost == fileSystemSpecificConfig.SysMgmtdHost {
			returnConfig.overwriteFrom(fileSystemSpecificConfig.Config)
		}
	}
	return returnConfig
}

// mountIfNecessary mounts a BeeGFS file system to mountDir/mount assuming configuration files have been written to
// mountDir by writeClientFiles (see above). The final directory structure looks like:
//                                            mountDirPath/
//                                                  |
//         +--------------------+-------------------+---------------------+----------------+
//         |                    |                   |                     |                |
// beegfs-client.conf   connInterfacesFile   connNetFilterFile   connTcpOnlyFilterFile   mount/
//                                                                                         |
//                                                                                 +-------+-------+
//                                                                                 |               |
//                                                                           beegfsSubdir1/   beegfsSubdir2/...
func mountIfNecessary(mountDirPath string) (err error) {
	var (
		// Effort has gone into maintaining consistent terminology for these various paths. Check other RPCs and
		// functions for consistency before refactoring.
		clientConfPath string // absolute path to beegfs-client.conf file; usually /mountDirPath/clientConfPath
		mountPath      string // absolute path to mount point
	)

	// TODO (webere): Support mount options
	clientConfPath = path.Join(mountDirPath, "beegfs-client.conf")
	mountPath = path.Join(mountDirPath, "mount")
	mountOpts := []string{"rw", "relatime", "cfgFile=" + clientConfPath}

	mounter := mount.New("/bin/mount")
	// Check to make sure file system is not already mounted.
	notMnt, err := mounter.IsLikelyNotMountPoint(mountPath)
	if err != nil {
		if os.IsNotExist(err) {
			// the file system can't be mounted because the mount point hasn't been created
			if err = os.Mkdir(mountPath, 0750); err != nil {
				return err
			}
			notMnt = true
		} else {
			return err
		}
	}

	if !notMnt {
		// The filesystem is already mounted. There is nothing to do.
		return err
	}

	glog.Infof("Mounting BeeGFS to %s", mountPath)
	if err = mounter.Mount("beegfs_nodev", mountPath, "beegfs", mountOpts); err != nil {
		return err
	}
	return nil
}

// unmountAndCleanUpIfNecessary cleans up a mounted BeeGFS filesystem ONLY if it is not bind mounted somewhere
// else. This is necessary to avoid trying to unmount a BeeGFS filesystem that is still in use by some container.
// "Cleans up" in this context means unmounts the BeeGFS filesystem, deletes the mount point (mountPath), and deletes
// all files under mountDirPath. unmountAndCleanUpIfNecessary also deletes mountDirPath if rmDir is set to true.
// unmountAndCleanUpIfNecessary deletes unmountANDCleanUpIfNecessary quietly continues WITHOUT error if the BeeGFS
// filesystem is not mounted.
func unmountAndCleanUpIfNecessary(mountDirPath string, rmDir bool) (err error) {
	var (
		// Effort has gone into maintaining consistent terminology for these various paths. Check other RPCs and
		// functions for consistency before refactoring.
		clientConfPath string // absolute path to beegfs-client.conf file; usually /mountDirPath/clientConfPath
		mountPath      string // absolute path to mount point
	)

	clientConfPath = path.Join(mountDirPath, "beegfs-client.conf") // See writeClientFiles for context.
	mountPath = path.Join(mountDirPath, "mount")                   // See writeClientFiles for context.

	// Decide whether or not to unmount BeeGFS filesystem by checking whether it is bind mounted somewhere else. We
	// cannot use beegfsMounter.GetRefs() because we are bind mounting subdirectories (e.g. .../volume1/mount is the
	// initial mount point but .../volume1/mount/volume1 is the directory we bind mount). beegfsMounter.GetRefs() is
	// incapable of discovering this.
	mounter := mount.New("")
	allMounts, err := mounter.List()
	if err != nil {
		return err
	}
	for _, entry := range allMounts {
		// Our container mounts the host's root filesystem at /host (like /:/host), so a file system might appear to be
		// mounted at both /path/to/file/system and /host/path/to/file/system. These duplicates are NOT bind mounts, so
		// we use !strings.Contains() instead of entry.Path != mountPath below.
		if entry.Device == "beegfs_nodev" && !strings.Contains(entry.Path, mountPath) {
			for _, opt := range entry.Opts {
				if strings.Contains(opt, clientConfPath) {
					// This is a bind mount of the BeeGFS filesystem mounted at mountPath
					return fmt.Errorf("refused to unmount staged file system at %v while bind mounted at %v",
						mountPath, entry.Path)
				}
			}
		}
	}

	if err = mount.CleanupMountPoint(mountPath, mounter, false); err != nil {
		return err
	}
	if err = cleanUpIfNecessary(mountDirPath, rmDir); err != nil {
		return err
	}
	return nil
}

// cleanUpIfNecessary deletes all files in the provided directory (usually at mountDirPath). It also deletes
// mountDirPath if rmDir is set to true.
func cleanUpIfNecessary(mountDirPath string, rmDir bool) (err error) {
	if rmDir == false {
		dir, err := ioutil.ReadDir(mountDirPath)
		if err != nil {
			return err
		}
		for _, d := range dir {
			if err = fs.RemoveAll(path.Join(mountDirPath, d.Name())); err != nil {
				return err
			}
		}
	} else {
		if err = fs.RemoveAll(mountDirPath); err != nil {
			return err
		}
	}
	return nil
}

// isUDPPortAvailable checks if a port is already listed in "sudo netstat -lu". This is a rudimentary implementation
// that doesn't validate if it was passed a valid port vs. some other string. If the port is already listed returns
// false, if the port is not listed returns true.
func isUDPPortAvailable(port string) (available bool, err error) {
	cmd, err := exec.Command("netstat", "-lu").Output()
	if err != nil {
		return false, fmt.Errorf("error '%s' checking if UDP port %s is available with netstat -lu", err, port)
	}
	if strings.Contains(string(cmd), port) {
		return false, nil
	}
	return true, err
}

// sanitizeVolumeID takes a volumeID like beegfs://127.0.0.1/scratch/vol1 and returns a string like
// 127.0.0.1_scratch_vol1. It is primarily used to generate sane directory names for the controller service, but may
// find other uses. sanitizeVolumeID replaces any _ in the provided volumeID with __ in the output to reduce ambiguity.
// sanitizeVolumeID returns a sha1 hash of the volumeID if the sanitized volumeID would be over 255 characters (the
// length limit for a file name in many file systems).
func sanitizeVolumeID(volumeID string) string {
	sanitizedVolumeID := strings.Replace(volumeID, "beegfs://", "", 1)
	sanitizedVolumeID = strings.Replace(sanitizedVolumeID, "_", "__", -1) // preserve existing _ as __
	sanitizedVolumeID = strings.Replace(sanitizedVolumeID, "/", "_", -1)
	if len(sanitizedVolumeID) > 255 {
		return fmt.Sprintf("%x", sha1.Sum([]byte(volumeID)))
	}
	return sanitizedVolumeID
}
